<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="style.css" rel="stylesheet">
</head>

<body>

    <h1>Comandi di GIT</h1>

    <h2>Help</h2>
    <p> Apre il browser con il readme di aiuto del comando specificato:</p>
    <code> & git nomecomando --help</code>

    <h2>Creare Repository</h2>
    <p>Creare un repository locale:</p>
    <code> & git init </code>
    <p>Clonare un repository remoto esistente:</p>
    <code> & git clone path/di/origin </code>

    <h2>Modifiche locali</h2>
    <p>Verificare cosa è successo dall'ultimo commit:</p>
    <code>& git status</code>
    <p>Aggiungere il file indicato, modificato rispetto all'ultimo commit, nello STAGE:</p>
    <code>& git add index.html</code>
    <p>Aggiungere tutti i file modificati nello STAGE (l'eventuale flag -p richiede di confermare ogni singola modifica):</p>
    <code>& git add .</code>
    <p>Rimuovere il file, precedentemente aggiunto, dallo STAGE, ma mantenendo le modifiche:</p>
    <code>& git reset -- index.html</code>
    <p>Committare i file, salvare uno snapshot dello stage:</p>
    <code>& git commit -m "Messaggio del commit"  </code>
    <p>Se si è dimenticato qualcosa dall'ultimo commit, combinare i file nello stage e l'ultimo commit (creando nella history
        un commit distinto):</p>
    <code>& git commit --amend  </code>
    <p>Vedere i dettagli di un commit:</p>
    <code>& git show 65476fa </code>
    <p>I <strong>tag</strong> sono utili per avere dei bookmark dei commit effettuati. Per marcare il commit corrente con un
        tag e poterlo in seguito confrontare con altri commit (mentre il flag -a permette di avere un tag annotato, cioè
        un msg):</p>
    <pre>
    <code>& git tag v1.0  </code>
    <code>& git -a 4b8e1ad // si specifica il commit da taggare  </code>
    </pre>

    <h2>Commit history</h2>
    <p>Mostra l'hash, l'autore e la data di tutti i commit partendo dal primo:</p>
    <code>& git log  </code>
    <p>Mostra le modifiche nel tempo di un unico file:</p>
    <code>& git log -p index.html </code>
    <p>Mostra chi ha cambiato, cosa e quando di un unico file:</p>
    <code>& git blame index.html </code>
    <p>Il flag --stat mostra l'hash, l'autore, la data e una sintesi dei file modificati, --oneline produce righe con hash e
        il msg del commit, mentre --decorate indica anche il branch e i tag, --graph disegna un grafico indicante il commit
        history. Si può formattare il log con --pretty=format:"%cn committed %h on %cd" o filtrare la commit history per
        data git log --after="2014-7-1" --before="2014-7-4" o per autore git log --author="John". Invece git shortlog riporta
        una lista dei commit suddivisi per autore.</p>

    <h2>Differenze</h2>
    <p>Mostra le differenze tra lo Stage e la working directory:</p>
    <code>& git diff  </code>
    <p>Mostra le differenze tra due commit:</p>
    <code>& git diff 65476fa 4b8e1ad </code>
    <p>Mostrare le differenze tra due branch:</p>
    <code>git diff branch_sorgente branch_target</code>
    <p>Mostrare le differenze tra un tag e la working directory (il flag --stat indica un resoconto dei cambiamenti)</p>
    <pre>
    <code>git diff v1.0</code>
    <code>git diff --stat nomebranch1 nomebranch2 // resoconto tra due branch</code>

    </pre>

    <h2>Branch</h2>
    <h3>Ogni qual volta si inizia una nuova feature, bugfix, o esperimento si deve creare un nuovo branch!.</h3>
    <p>Mostrare tutti i branch correnti:</p>
    <code>& git branch -av  </code>
    <p>Per switchare ad un branch specifico:</p>
    <code>& git checkout nomebranch  </code>
    <p>Creare un nuovo branch basato sull'ultimo commit (HEAD):</p>
    <code>& git branch nomebranch </code>
    <p>Crea un nuovo branch chiamato "feature_x" e passa al nuovo branch usando:</p>
    <code>& git checkout -b feature_x</code>
    <p>Creare un nuovo branch basato su un brach remoto:</p>
    <code>& git checkout --track path/remote/branch  </code>
    <p>Cancellare un branch locale:</p>
    <code>& git branch -d nomebranch  </code>
    <p>Cancellare un branch remoto:</p>
    <code>& git branch -dr remote/branch </code>
    <p>Il branch non sarà disponibile agli altri fino a quando non verrà inviato al repository remoto</p>
    <code>$ git push origin <branch></code>

    <h2>Stash</h2>
    <h3>Siamo nel mezzo dello sviluppo di qualche funzionalità , ma emerge la necessità di interrompere tutto per dedicarsi al
        bugfix sul commit precedente: non si può perdere il lavoro non committato e si accantona il codice non committatato
        (lo stato della working directory e dell'index) e si ritorna allo stato dell'ultimo commit con uno stato pulito della
        working directory:</h3>
    <pre>
        <code>git stash -a "nomeStash"</code>
        <code>git stash list // elenca una coda di stash</code>
        <code>git stash apply // quando si è pronti a ritornare da dove si era lasciato il comando riporta indietro ai cambiamenti fatti nella workind directory</code>
        <code>git stash pop   // stessa cosa di apply ma rimuove lo stato dallo stash list</code>
        <code>git stash drop  // rimuove l'ultimo stash</code>
        <code>git stash clear // pulisce la lista di stash</code>
    </pre>

    <h2>Update and Publish</h2>
    <h3>Repository remoti</h3>
    <pre>
        <code>$ git remote -v // dà la lista dedi repository remoti</code>
        <code>$ git remote show https://gitlab.cloud.net/ApplicationSkeleton  // mostra informazioni del remote</code>
        <code>$ git remote add nomebranch https://gitlab.cloud.net/nomebranch // aggiungi un repository remoto</code>
        <code>$ git fetch nomeremote // scarica tutte le modifiche da nomeremote ma non integrarle nell'HEAD</code>
        <code>$ git pull nomeremote // scarica tutte le modifiche da nomeremote e le integra mergiandole nell'HEAD</code>
        <code>$ git push nomeremote nomebranch  // pubblica le modifiche locali sul remoto</code>
    </pre>

    <h2>Merge & Rebase</h2>
    <h3>In GIT ci sono due modi per integrare i cambiamenti da un ramo all'altro: MERGE e REBASE</h3>
    <h4>Merge</h4>
    <p>Il comando <strong>merge</strong> crea un nuovo commit che include le modifiche provenienti da altri commit. Si dice
        che si mergia il ramo di origine nel ramo di destinazione.</p>
    <pre>
         <code>$ git chechout featurebranch // si va nel ramo che riceverà (ramo di destinazione)</code>
         <code>$ git rebase master // si specifica da chi prendere i commit (ramo di origine)</code>
     </pre>

    <h4>Rebase (Rifondazione)</h4>
    <p>Il comando <strong>rebase</strong> sposta il ramo featurebranch all'estremità del master e tutti i commit di questo vengono
        inclusi nel ramo di destinazione. Si ha così una rifondazione della cronologia del progetto. Se il merge crea un
        singolo commit con due genitori preservando l'history non lineare, un rebase riporta i commit dal branch corrente
        su un altro producendo una history lineare. E' un modo automatizzato di eseguire in sequenza diversi cherry-pick.</p>
    <pre>
         <code>$ git chechout featurebranch // si va nel ramo che riceverà (ramo di destinazione)</code>
         <code>$ git merge master // si specifica da chi prendere le modifiche (ramo di origine delle modifiche)</code>
     </pre>

    <h4>Conflicts</h4>
    <p>Per risolvere i conflitti si utilizzano vari tool. Per incorporare un altro branch nel tuo branch attivo, utilizza git
        merge nomebranch, e git prova ad auto-incorporare le modifiche. Sfortunatamente, a volte questa procedura automatizzata
        non è possibile, ed in questo caso ci saranno dei conflitti. Sei tu il responsabile che sistemerà questi conflitti
        manualmente modificando i file che git mostrerà. Dopo aver cambiato questi files, dovrai marcarli come 'correttamente
        incorporati' tramite 'git add nomedelfileeditato' e prima di immettere le modifiche.</p>
    <pre>
     <code>$ git mergetool // usa il tool configurato per risolvere i conflitti</code>
     <code>$ git diff branch_sorgente branch_target</code>
     <code>$ git add resolved-file // marcare i file come risolti</code>
     </pre>

    <h4>Cherry Pick</h4>
    <p>Per copiare un commit da un branch ad un altro si utilizza il comando <strong>cherry-pick</strong>. Il comando copia
        un commit creandone uno nuovo nel branch corrente con lo stesso msg dell'originale applicando le modifiche come se
        fosse un commit diverso. </p>
    <code>$ git cherry-pick 65476fa</code>



    <h2>UNDO</h2>
    <p>Per vedere temporaneamente un commit:</p>
    <pre>
        <code>$ git checkout 65476fa </code>
        <code>$ git checkout 65476fa index.html // per vedere temporanemante solo un file</code>
        <code>$ git checkout master  // per tornare allo stato “current” del progetto</code>
    </pre>

    <p>Elimina le modifiche locali nella working directory, ritornando all'ultimo committed state:</p>
    <code>$ git reset --hard HEAD // HEAD si può omettere sta per branch corrente</code>

    <p>Nel caso tu abbia fatto qualcosa di sbagliato si può sostituire i cambiamenti fatti in locale con il comando 'git checkout -- nomedelfile' questo rimpiazza le modifiche nell'albero di lavoro con l'ultimo contenuto presente in HEAD. I cambiamenti fatti ed aggiunti all'index, così come i nuovi files, verranno mantenuti.</p>
    <code>$ git checkout HEAD  index.html // oppure git checkout -- index.html </code>

    <p>E' possibile inoltre fare un revert del commit (producendo un nuovo commit con modifiche opposte, si cancella quindi commit pubblicati con nuovi commit che prevengono la perdita della commit history. E' utile quando un commit ha introdotto dei bug che possono essere rimossi facendo il revert del commit.</p>
    <pre>
        <code>$ git revert 65476fa</code>
        <code>$ git revert HEAD~2..HEAD // fa il revert degli ultimi due commit</code>
    </pre>

    <p>Ritornare indietro al commit indicato, modificando l'history dei commit.</p>
    <pre>
        <code>$ git reset --hard 65476fa // ...elimina le modifiche locali nella working directory</code>
        <code>$ git reset  65476fa // ...preserva le modifiche dei commit successivi a quello indicato e messi come unstaged</code>
        <code>$ git reset --keep 65476fa // ...e preserva modifiche locali non committate.</code>
        <br>
        <code>// If I want to keep the last changes...</code>
        <code>$ git stash -a "feature"</code>
        <code>$ git reset --hard 65476fa</code>
        <code>$ git stash apply "feature"</code>
    </pre>


    <h3>Utilities</h3>
    <p>Cerca nella working directory il testo 'pippo'</p>
    <code>$ git grep "pippo"</code>

    <h2>Links:</h2>
    <a href="http://marklodato.github.io/visual-git-guide/index-en.html">Visual Guide</a>
    <script src="app.js"></script>
</body>

</html>